clear; clc; close all;

%% --- MÅL, START OG HINDRING ----------------------------------------
% Start- og målposisjon (samme koordinatsystem som i P-kontrollerfiguren)
x_start = 3.0;   y_start = 0.0;
x_goal  = 2.0;   y_goal  = 8.0;

% Hindring: sirkel som ligger på m-line mellom start og mål
% Vi antar at (obs_cx, obs_cy, obs_R) er estimert fra lidar/3D-kamera
obs_cx   = 2.0;   % senter x
obs_cy   = 4.0;   % senter y
obs_R    = 0.6;   % radius [m]
sikkerhet = 0.6;  % sikkerhetsmargin [m]
hit_dist  = obs_R + sikkerhet;  % (kan brukes hvis du vil)
hit_range = sikkerhet;          % terskel for avstand til overflate

% m-line (rett linje mellom start og mål) brukes flere steder
m_dx = x_goal - x_start;
m_dy = y_goal - y_start;
m_norm = hypot(m_dx, m_dy);        % |m-line vektor|

%% --- SENSORPARAMETRE (LIDAR) ----------------------------------------
lidar_max_range = 5.0;    % maks rekkevidde [m]
lidar_sigma     = 0.01;   % støy på målt avstand [m] (liten, for demo)

%% --- KONTROLLER- OG SIMULASJONSPARAMETRE ---------------------------
Kp_theta  = 2.0;    % P-forsterker på retningsfeil
v_frem    = 0.4;    % konstant fremoverhastighet [m/s]

dt        = 0.05;   % tidssteg [s]
T_slutt   = 60;     % maks simuleringstid [s]
N_max     = round(T_slutt/dt);

goal_tol  = 0.15;   % avstandsterskel for å "ha nådd målet" [m]
mline_tol = 0.05;   % hvor nær m-line vi må være for å si "på m-line" [m]

%% --- ARRAYER FOR LAGRING AV TILSTAND -------------------------------
x     = nan(1, N_max);
y     = nan(1, N_max);
theta = nan(1, N_max);
omega = nan(1, N_max);
state_log = strings(1, N_max);  % for å logge hvilken BUG2-tilstand vi er i

% initialtilstand
x(1)     = x_start;
y(1)     = y_start;
theta(1) = pi/2;         % peker oppover langs +y
state_log(1) = "GOAL_STATE";

% Variabler relatert til BUG2-logikk
state = "GOAL_STATE";    % kan være "GOAL_STATE" eller "BOUNDARY_STATE"
hit_point = [NaN; NaN];  % posisjon der vi først traff hindringen
dist_goal_at_hit = NaN;  % avstand til mål ved treffpunkt

% Flag for å bare skrive forklaring én gang
printed_explanation = false;

%% --- HJELPEFUNKSJON FOR VINKELDIFF ---------------------------------
angdiff = @(a,b) atan2(sin(a-b), cos(a-b));   % gir vinkel i [-pi, pi]

%% --- HOVEDLØKKE -----------------------------------------------------
k = 1;
while k < N_max

    % Avstand til mål (perfekt info, f.eks. GPS/SLAM)
    dist_goal = hypot(x_goal - x(k), y_goal - y(k));

    % Stopp om vi er ved målet
    if dist_goal < goal_tol
        fprintf('Mål nådd ved k = %d, tid = %.2f s\n', k, (k-1)*dt);
        break;
    end

    % (Perfekt) avstand til hindringens senter (modell etter sensorprosessering)
    dist_obs_center = hypot(x(k) - obs_cx, y(k) - obs_cy); %#ok<NASGU>

    % --- SENSORMÅLING (LIDAR FRONT) --------------------------------
    % Simulerer en 2D-lidarstråle rett frem i robotens heading.
    [range_front_true, hit_x, hit_y] = lidar_ray_circle( ...
        x(k), y(k), theta(k), ...
        obs_cx, obs_cy, obs_R, ...
        lidar_max_range);

    % Legg på litt (valgfri) støy
    range_front_meas = range_front_true + lidar_sigma * randn;

    switch state
        case "GOAL_STATE"
            % ---------------------------------------------------------
            % TRINN 1: KJØR RETT MOT MÅL (langs m-line)
            % ---------------------------------------------------------

            % Ønsket retning mot målet
            theta_des = atan2(y_goal - y(k), x_goal - x(k));
            e_theta   = angdiff(theta_des, theta(k));
            omega(k)  = Kp_theta * e_theta;
            v         = v_frem;

            % Sjekk om vi treffer hindringen, basert på LIDAR
            if range_front_meas <= hit_range
                % lagre treffpunkt (basert på posisjon)
                hit_point = [x(k); y(k)];
                dist_goal_at_hit = dist_goal;
                state = "BOUNDARY_STATE";
                fprintf('Bytter til BOUNDARY_STATE ved t = %.2f s\n', (k-1)*dt);

                % -----------------------------------------------------
                % PRINT: forklar hvordan sensordata -> kontroll
                % (gjøres bare én gang)
                % -----------------------------------------------------
                if ~printed_explanation
                    printed_explanation = true;

                    % Beregn b, c og diskriminant for forklaringen
                    dx = cos(theta(k));
                    dy = sin(theta(k));
                    fx = x(k) - obs_cx;
                    fy = y(k) - obs_cy;
                    b  = fx*dx + fy*dy;
                    c  = fx^2 + fy^2 - obs_R^2;
                    disc = b^2 - c;

                    fprintf('\n======================================================\n');
                    fprintf(' DEMONSTRASJON: Hvordan sensordata brukes til å styre roboten\n');
                    fprintf('======================================================\n');
                    fprintf('Ved tid t = %.2f s registrerer front-lidaren hindringen.\n\n', (k-1)*dt);

                    fprintf('1) Rå sensordata (lidarmåling):\n');
                    fprintf('   Robotposisjon: x = %.3f, y = %.3f, theta = %.3f rad\n', ...
                            x(k), y(k), theta(k));
                    fprintf('   Målt avstand r_målt = %.3f m (stråle rett frem)\n\n', ...
                            range_front_meas);

                    fprintf('2) Geometrisk sammenheng mellom lidarstråle og hindring:\n');
                    fprintf('   Lidarstrålen starter i robotens posisjon p_R = [x; y].\n');
                    fprintf('   Strålen peker i retning d = [cos(theta); sin(theta)].\n');
                    fprintf('   Ethvert punkt langs strålen kan skrives som:\n');
                    fprintf('       p(t) = p_R + t * d,   t >= 0.\n');
                    fprintf('   Hindringen modelleres som en sirkel:\n');
                    fprintf('       (X - c_x)^2 + (Y - c_y)^2 = R^2.\n');
                    fprintf('   Setter vi inn p(t) i sirkelelikningen får vi en andregradsligning i t:\n');
                    fprintf('       t^2 + 2*b*t + c = 0\n');
                    fprintf('   der:\n');
                    fprintf('       b = (x - c_x)*cos(theta) + (y - c_y)*sin(theta)\n');
                    fprintf('       c = (x - c_x)^2 + (y - c_y)^2 - R^2\n\n');

                    fprintf('   For dette tidssteget gjelder:\n');
                    fprintf('       b = %.5f\n', b);
                    fprintf('       c = %.5f\n', c);
                    fprintf('       diskriminant = b^2 - c = %.5f\n\n', disc);

                    fprintf('   Den minste positive løsningen t_hit er den virkelige avstanden\n');
                    fprintf('   langs strålen til hindringens overflate:\n');
                    fprintf('       range_sann = t_hit = %.3f m\n', range_front_true);
                    fprintf('   Treffpunktet p_treff = p_R + t_hit * d er:\n');
                    fprintf('       p_treff = [%.3f; %.3f]\n\n', hit_x, hit_y);

                    fprintf('3) Fra sensordata til nyttig kontrollsignal:\n');
                    fprintf('   Vi sammenlikner målt avstand r_målt med en sikkerhetsterskel\n');
                    fprintf('   hit_range = %.3f m.\n', hit_range);
                    fprintf('   Siden r_målt <= hit_range tolkes dette som at hindringen er nådd,\n');
                    fprintf('   og BUG2-tilstanden endres:\n');
                    fprintf('       tilstand: GOAL_STATE -> BOUNDARY_STATE.\n\n');

                    fprintf('   I BOUNDARY_STATE beregnes vinkelen fra hindringens sentrum til\n');
                    fprintf('   roboten:\n');
                    fprintf('       phi = atan2(y - c_y, x - c_x).\n');
                    fprintf('   Tangentretningen for veggfølging (med klokka) blir:\n');
                    fprintf('       theta_tangent = phi - pi/2.\n');
                    fprintf('   Deretter brukes en P-regulator på retningsfeilen:\n');
                    fprintf('       omega = Kp_theta * (theta_tangent - theta).\n\n');

                    fprintf('   Dette viser trinn for trinn hvordan rå sensordata (lidaravstand)\n');
                    fprintf('   omdannes til geometrisk informasjon og deretter til\n');
                    fprintf('   et styresignal (omega, v) som styrer robotens bevegelse.\n');
                    fprintf('======================================================\n\n');
                end
            end

        case "BOUNDARY_STATE"
            % ---------------------------------------------------------
            % TRINN 2: FØLG HINDRINGENS KANT (sirkel rundt)
            % ---------------------------------------------------------

            % Vinkel fra hindrings-senter til robot
            phi = atan2(y(k) - obs_cy, x(k) - obs_cx);

            % Tangentretning for å følge hindringen med klokka
            theta_tangent = phi - pi/2;  % CW rundt hindringen

            % P-regulator på vinkel mot tangent (veggfølging)
            e_theta  = angdiff(theta_tangent, theta(k));
            omega(k) = Kp_theta * e_theta;
            v        = v_frem;

            % Sjekk om vi bør forlate hindringen (BUG2-kriterium)
            % 1) Vi må være på m-line igjen
            % 2) Vi må være nærmere målet enn da vi traff hindringen
            d_mline = abs(m_dy*(x(k)-x_start) - m_dx*(y(k)-y_start)) / m_norm;

            if d_mline < mline_tol && dist_goal < (dist_goal_at_hit - 1e-3)
                state = "GOAL_STATE";
                fprintf('Forlater hindring og går tilbake til GOAL_STATE ved t = %.2f s\n', ...
                        (k-1)*dt);
            end
    end

    % Logg tilstand
    state_log(k) = state;

    % --- UNICYCLE-KINEMATIKK ----------------------------------------
    x_dot     = v * cos(theta(k));
    y_dot     = v * sin(theta(k));
    theta_dot = omega(k);

    x(k+1)     = x(k)     + x_dot     * dt;
    y(k+1)     = y(k)     + y_dot     * dt;
    theta(k+1) = theta(k) + theta_dot * dt;

    k = k + 1;
end

% Trim arrayer til faktisk lengde
x     = x(1:k);
y     = y(1:k);
theta = theta(1:k);
omega = omega(1:k);
state_log = state_log(1:k);
t = (0:k-1) * dt;

%% --- PLOTT: BANE + HINDRING + M-LINE -------------------------------
figure(1); clf; hold on; grid on; axis equal;
title('Mobil robot – BUG2 med simulert lidar');
xlabel('x [m]'); ylabel('y [m]');

% Vegg (valgfritt)
x_vegg = 0;
y_aksen = linspace(min(y)-1, max(y)+1, 2);
plot(x_vegg * ones(size(y_aksen)), y_aksen, 'k--', 'LineWidth', 1.5);

% M-line
plot([x_start x_goal], [y_start y_goal], 'g-.', 'LineWidth', 1.5);

% Hindring (sirkel)
th = linspace(0, 2*pi, 100);
plot(obs_cx + obs_R*cos(th), obs_cy + obs_R*sin(th), 'r', 'LineWidth', 2);

% Robotbane
plot(x, y, 'b', 'LineWidth', 2);
plot(x(1), y(1), 'bo', 'MarkerFaceColor', 'b');       % start
plot(x(end), y(end), 'ro', 'MarkerFaceColor', 'r');   % slutt

legend({'Vegg (x = 0)', 'M-line', ...
        'Hindring', 'Robotbane', 'Start', 'Slutt'}, ...
        'Location', 'best');

%% --- PLOTT: VINKELHASTIGHET OG TILSTAND ----------------------------
figure(2); clf; 
subplot(2,1,1);
plot(t, omega, 'b', 'LineWidth', 1.5); grid on;
xlabel('Tid [s]'); ylabel('\omega(t) [rad/s]');
title('Styresignal fra P-kontroller (retningsfeil)');

subplot(2,1,2);
stairs(t, state_log == "GOAL_STATE", 'LineWidth', 1.5); grid on;
ylim([-0.1 1.1]);
yticks([0 1]); yticklabels({'BOUNDARY','GOAL'});
xlabel('Tid [s]'); ylabel('Tilstand');
title('BUG2-tilstand (1 = GOAL\_STATE, 0 = BOUNDARY\_STATE)');

%% --- LOKAL FUNKSJON: LIDAR-RAY MOT SIRKEL --------------------------
function [range, px, py] = lidar_ray_circle(x, y, theta, cx, cy, R, max_range)
    % Simulerer en enkel 2D-lidarstråle:
    %  - Startpunkt: (x, y)
    %  - Retning: theta
    %  - Hindring: sirkel med sentrum (cx, cy) og radius R
    %  - Returnerer:
    %       range = avstand til sirkel-overflaten langs strålen
    %               (eller max_range hvis ingen treff)
    %       (px, py) = treffe-punkt (eller punkt langt ute hvis ingen treff)

    dx = cos(theta);
    dy = sin(theta);

    % Flytt koordinatsystemet slik at sirkel-senter er i origo
    fx = x - cx;
    fy = y - cy;

    % Løs (fx + dx*t)^2 + (fy + dy*t)^2 = R^2 for t >= 0
    % => t^2 + 2b t + c = 0
    b = fx*dx + fy*dy;
    c = fx^2 + fy^2 - R^2;

    disc = b^2 - c;
    if disc < 0
        % Ingen skjæring
        range = max_range;
        px = x + max_range*dx;
        py = y + max_range*dy;
        return;
    end

    t1 = -b - sqrt(disc);
    t2 = -b + sqrt(disc);

    % Vi vil ha minste positive t
    ts = [t1 t2];
    ts = ts(ts >= 0);

    if isempty(ts)
        range = max_range;
        px = x + max_range*dx;
        py = y + max_range*dy;
        return;
    end

    t_hit = min(ts);
    if t_hit > max_range
        range = max_range;
        px = x + max_range*dx;
        py = y + max_range*dy;
        return;
    end

    range = t_hit;
    px = x + t_hit*dx;
    py = y + t_hit*dy;
end
